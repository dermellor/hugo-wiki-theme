{{ define "title" }}{{ .Title | markdownify }} | {{ .Site.Title }}{{ end }}

{{ define "schema-dot-org" }}
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  {{- /* Google recommends the headline be no more than 110 characters */}}
  "headline": {{ substr .Title 0 110 }},
  {{- with .Params.images -}}{{ range first 1 . }}
  "image": {
    "@type": "ImageObject",
    "url": {{ . | absURL }}
    {{- /* Don't try to get imageConfig if image param is not local */ -}}
    {{- if not (or (hasPrefix . "http://") (hasPrefix . "https://")) -}}
    {{- with (imageConfig (printf "/static/%s" .)) -}}
    ,
    "height": "{{ .Height }}",
    "width": "{{ .Width }}"
    {{- end -}}
    {{ end }}
  },
  {{- end -}}{{ end }}
  "url": {{ printf "%s" .Permalink }},
  "wordCount": "{{ .WordCount }}",
  {{- $ISO8601 := "2006-01-02T15:04:05-07:00" }}
  {{- if not .PublishDate.IsZero }}
  "datePublished": {{ .PublishDate.Format $ISO8601 }},
  {{- else }}
  "datePublished": {{ .Date.Format $ISO8601 }},
  {{- end }}
  {{- if not .Lastmod.IsZero }}
  "dateModified": {{ .Lastmod.Format $ISO8601 }},
  {{- end }}
  "author": {
    "@type": "Person",
    "name": {{ .Params.author | default .Site.Params.author }}
  }
  {{- if or (.Params.keywords) (or (.Params.categories) (.Params.tags)) -}}
  ,
  "keywords": {{ delimit (union .Params.keywords (union .Params.categories .Params.tags)) ", " }}
  {{- end }}

  {{- with .Params.description -}}
  ,
  "description": {{ . }}
  {{- end }}
}
</script>

{{ end }}

{{ define "main" }}
{{ $dateFormat := default "Mon Jan 2, 2006" (index .Site.Params "date_format") }}

{{- $title :=  (printf "%s %s %s" "<h1>" (.Title | markdownify)  "</h1>") | safeHTML -}}
{{- $body := partial "content-wikilinks" . }}

{{ if  strings.Contains .Content "h1" }}
  {{- $title =  (printf "%s %s" (index (split .Content "</h1>") 0 ) "</h1>") | safeHTML -}}
  {{- $body =  (index (split (partial "content-wikilinks" .) "</h1>") 1) | safeHTML }}
{{ end }}


  <header class="">
    <div class="container-fluid pt-3 p-lg-5 pt-lg-3">
        <div class="row">
          <div class="col-xl-10 col-xxl-8 offset-xxl-2">
            {{if eq .Section "posts"}}
              {{ if or (.Params.categories) (.Params.tags) }} {{ partial "meta-terms.html" . }}{{ end }}
            {{end}}
          {{ $title }}
          </div>
          <div class="col-12 col-xxl-8 offset-xxl-2">
            {{ if .Params.audio }}
              <div class="mt-3 mb-5">
                {{ partial "audio-header" (dict "file" .Params.audio ) }}
              </div>
            {{ else }}
              <hr/ class="my-5">
            {{ end }}
          </div>
        </div>
        {{if eq .Section "posts"}}
        <div class="row">
          <div class="col-lg-5 col-xxl-4 offset-xxl-2 mb-4 mb-lg-0">
            <div class="article-illustration" style="background-image: url( {{ partial "article-image" . }} ); "></div>
          </div>
          <div class="col-lg-7 col-xxl-4 {{if (partial "article-image" .)}} {{else}}  {{end}} d-flex align-items-start flex-column">
              <div class="lead d-flex w-100 mb-3 fw-bold ">
                <div class=""><time {{ .Date.Format "2006-01-02T15:04:05Z07:00" | printf "datetime=%q" | safeHTMLAttr }}>{{ .Date.Format $dateFormat }}</time></div>
                <div class="ms-auto">
                    Artikel teilen
                    <a href="https://www.linkedin.com/shareArticle?mini=true&url={{ .Permalink }}"><i class="bi-linkedin ps-2"></i></a>
                    <a href="mailto:?subject={{ .Title | safeURL }}&body={{ .Permalink  | safeURL }}"><i class="bi-send ps-2"></i></a>
                </div>
              </div>
              <p class="lead mt-auto lh-sm fw-bold mb-5 mb-lg-0">
                {{if .Params.teaser }}
                  {{ .Params.teaser }}
                {{ else if .Params.description -}}
                  {{ .Params.description }}
                {{- end }}
              </p>
            </div>
        </div>
        {{ end }}
    </div>
  </header>

  <div class="container-fluid p-lg-5">
    <div class="row">
      <div class="col-md-8 col-lg-6 col-xxxl-5 offset-md-2 offset-lg-3 blog-main m-xxxl-auto">
        <article class="blog-post">
            {{ $body }}
          </article>

          <div class="comment-section mt-5">
            <hr/>
            <h3>Kommentare</h3>
            <div id="comments" class="mt-4"></div>
  
            <div id="login-prompt" class="alert alert-info mt-4" style="display:none;">
              Du musst <a href="#" id="comment-login-link">eingeloggt sein</a>, um kommentieren zu können.
            </div>
  
            <div id="user-info" class="mt-4 mb-2" style="display:none;">
              <small>Du kommentierst als <strong id="current-username">Gast</strong></small>
            </div>
  
            <form id="comment-form" class="mt-2" style="display:none;">
              <div class="mb-3">
                <textarea id="comment-content" class="form-control" placeholder="Dein Kommentar" rows="3"></textarea>
              </div>
              <button type="submit" class="btn btn-primary">Kommentar abschicken</button>
            </form>
          </div>
          
        </div>
      </div>
  </div>


<div class="container-fluid py-4 p-lg-5 bg-light">
  <div class="row">

    <div class="col-12 col-xxl-8 offset-xxl-2">

      <!--

      {{ if .IsTranslated }}
      <h4>{{ i18n "translations" }}</h4>
      <ul>
        {{ range .Translations }}
        <li>
          <a href="{{ .Permalink }}">{{ .Lang }}: {{ .Title }}{{ if .IsPage }}{{ end }}</a>
        </li>
        {{ end }}
      </ul>
      {{ end }}
      -->
      
      {{ if and (ne .Params.newsletter nil) ( ne .Params.newsletter "") }}
        <strong>
            {{ $newsletterNumber := findRESubmatch  "newsletter\\/(.+)" .Params.newsletter 1 }}
            {{ $newsletterNumber = index (index $newsletterNumber 0) 1 }}
            Dieser Artikel erschien in Ausgabe {{ $newsletterNumber }} meines wöchentlichen Newsletters "Tech is Good". Du kannst ihn <a href="/newsletter">hier abonnieren</a>.
        </strong>

      {{ end }}

      
      <footer>

      {{if eq .Section "posts"}}

        {{ if (ne ($.Param "sharingicons") false) }}
        {{ partial "sharing-icons.html" . }}
        {{ end }}


      
      <script>
        // Elemente für UI-Status
        const commentForm = document.getElementById('comment-form');
        const loginPrompt = document.getElementById('login-prompt');
        const userInfo = document.getElementById('user-info');
        const currentUsername = document.getElementById('current-username');

        // Funktion zum Aktualisieren der UI basierend auf Login-Status
        async function updateCommentUI() {
          if (window.supabaseSession?.access_token) {
            // Benutzer ist eingeloggt
            try {
              // Benutzerdaten abrufen
              const { data: { user } } = await supabaseClient.auth.getUser();

              // Benutzernamen abrufen
              const { data, error } = await supabaseClient
                .from('usernames')
                .select('username')
                .eq('user_id', user.id)
                .single();

              const username = data?.username || user.email || 'Anonymer Nutzer';

              // UI aktualisieren
              currentUsername.textContent = username;
              userInfo.style.display = 'block';
              commentForm.style.display = 'block';
              loginPrompt.style.display = 'none';
            } catch (error) {
              console.error('Fehler beim Abrufen der Benutzerdaten:', error);
              userInfo.style.display = 'none';
              commentForm.style.display = 'block';
              loginPrompt.style.display = 'none';
            }
          } else {
            // Benutzer ist nicht eingeloggt
            userInfo.style.display = 'none';
            commentForm.style.display = 'none';
            loginPrompt.style.display = 'block';
          }
        }

        // Initial UI aktualisieren
        updateCommentUI();

        // Auth-State-Änderung abfangen
        document.addEventListener('supabase-auth-change', (event) => {
          updateCommentUI();
        });

        // Login-Link im Kommentarbereich
        const commentLoginLink = document.getElementById('comment-login-link');
        if (commentLoginLink) {
          commentLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            const loginModal = new bootstrap.Modal(document.getElementById('login-modal'));
            loginModal.show();
          });
        }

        // Kommentar absenden mit Supabase SDK
        document.getElementById('comment-form').addEventListener('submit', async (e) => {
          e.preventDefault();

          const content = document.getElementById('comment-content').value;
          if (!content.trim()) {
            alert('Bitte gib einen Kommentar ein.');
            return;
          }

          const page = window.location.pathname;

          // Benutzerdaten abrufen
          const { data: { user } } = await supabaseClient.auth.getUser();
          const author_id = user?.id;

          if (!author_id) {
            alert('Du musst eingeloggt sein, um zu kommentieren.');
            return;
          }

          // Kommentar mit Supabase SDK speichern
          // Neue Kommentare sind standardmäßig nicht veröffentlicht (published=false)
          const { data, error } = await supabaseClient
            .from('comments')
            .insert([{
              content,
              page,
              author_id,
              published: false  // Standardmäßig nicht veröffentlicht
            }]);

          if (error) {
            console.error('Fehler beim Speichern des Kommentars:', error);
            alert('Fehler beim Speichern: ' + error.message);
            return;
          }

          // Formular zurücksetzen und Kommentare neu laden
          document.getElementById('comment-content').value = '';
          loadComments();
        });

        // Kommentare laden mit Supabase SDK
        async function loadComments() {
          const page = window.location.pathname;

          // Benutzerdaten für Benutzerabhängige Kommentaranzeige
          const { data: { user } } = await supabaseClient.auth.getUser();
          const currentUserId = user?.id;

          // Kommentare mit Supabase SDK abrufen
          let query = supabaseClient
            .from('comments')
            .select(`
              content,
              created_at,
              author_id,
              published
            `)
            .eq('page', page);

          // Filter nur veröffentlichte Kommentare, es sei denn es sind die eigenen
          if (currentUserId) {
            // Wenn Benutzer eingeloggt, zeige veröffentlichte Kommentare oder eigene
            query = query.or(`published.eq.true,author_id.eq.${currentUserId}`);
          } else {
            // Wenn Benutzer nicht eingeloggt, zeige nur veröffentlichte Kommentare
            query = query.eq('published', true);
          }

          // Abfrage ausführen
          const { data, error } = await query.order('created_at', { ascending: false });

          if (error) {
            console.error('Fehler beim Laden der Kommentare:', error);
            return;
          }

          const container = document.getElementById('comments');
          container.innerHTML = '';

          if (!data || data.length === 0) {
            const noComments = document.createElement('p');
            noComments.className = 'text-muted';
            noComments.textContent = 'Keine Kommentare vorhanden. Sei der Erste, der einen Kommentar hinterlässt!';
            container.appendChild(noComments);
            return;
          }

          // Benutzernamen für die Kommentare abrufen
          const authorIds = data.map(comment => comment.author_id).filter(id => id); // Filtere alle null/undefined Werte
          let usernames = {};

          if (authorIds.length > 0) {
            try {
              const { data: usernameData, error: usernameError } = await supabaseClient
                .from('usernames')
                .select('user_id, username')
                .in('user_id', authorIds);

              if (!usernameError && usernameData) {
                // Benutzernamen in Map umwandeln für schnellen Zugriff
                usernameData.forEach(item => {
                  usernames[item.user_id] = item.username;
                });
              }
            } catch (err) {
              console.error('Fehler beim Laden der Benutzernamen:', err);
            }
          }

          data.forEach(comment => {
            const commentWrapper = document.createElement('div');
            commentWrapper.className = 'comment-wrapper mb-4';

            // Nicht veröffentlichte Kommentare haben eine andere Hintergrundfarbe
            if (!comment.published) {
              commentWrapper.classList.add('bg-light', 'p-3', 'border', 'border-warning');
            }

            // Username header
            const usernameEl = document.createElement('strong');
            const username = usernames[comment.author_id] || 'Anonymer Nutzer';
            usernameEl.textContent = username;
            commentWrapper.appendChild(usernameEl);

            // Timestamp
            const timestamp = document.createElement('small');
            timestamp.className = 'text-muted ms-2';
            const date = new Date(comment.created_at);
            timestamp.textContent = date.toLocaleDateString('de-DE', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
            commentWrapper.appendChild(timestamp);

            // Status Badge für nicht veröffentlichte Kommentare (eigene)
            if (!comment.published && comment.author_id === currentUserId) {
              const pendingBadge = document.createElement('span');
              pendingBadge.className = 'badge bg-warning text-dark ms-2';
              pendingBadge.textContent = 'Genehmigung ausstehend';
              commentWrapper.appendChild(pendingBadge);
            }

            // Comment content
            const contentEl = document.createElement('p');
            contentEl.className = 'mt-1';
            contentEl.textContent = comment.content;
            commentWrapper.appendChild(contentEl);

            // Hinweis für nicht veröffentlichte Kommentare
            if (!comment.published && comment.author_id === currentUserId) {
              const hintEl = document.createElement('small');
              hintEl.className = 'text-muted d-block mt-1';
              hintEl.textContent = 'Dein Kommentar wird nach der Überprüfung für alle sichtbar sein.';
              commentWrapper.appendChild(hintEl);
            }

            container.appendChild(commentWrapper);
          });
        }

        loadComments();
      </script>

        {{ if $.Param "newsletter_cta" }}

          {{ if (ne ($.Param "newsletter_subscription_address") false) }}
            {{ partial "newsletter.html" . }}
          {{ end }}

        {{ else }}
          {{ partial "newsletter/form/big.html" (dict "utm_medium" "post") }}
        {{ end }}


      {{ end }}

      {{ if and (ne .Params.appendix nil) ( ne .Params.appendix "") }}
        <p>
          {{ .Params.appendix | markdownify }}
        </p>
      {{ end }}

      </footer>

    </div>

  </div>

</div>


{{ end }}

{{- /* vim: set ts=2 sw=2 et: */}}
